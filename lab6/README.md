# Распределённые эволюционные алгоритмы
## Цель работы
Целью данной работы является освоение принципов построения распределённых и параллельных эволюционных алгоритмов для повышения их произвдительности и эффективности.

## Выполнениие работы
В рамках рыботы были выполнены следующие действия:

1. Был скопирован шаблон [проекта](https://gitlab.com/itmo_ec_labs/lab5).
2. В данный шаблон были скопированы файлы из второй лабараторной работы с реализациями операторов
инициализации, кроссовера и мутации.
3. Была произведена модификация класса ```IslandAlg``` с целью добавления инициализации алгоритма островной эволюции. В качестве реализации стратегии миграции была выбрана ```RingMigration```. Суть
этой стратегии заключается в том, что острова образуют кольцо, в котором каждый остров обменивается
случайными особями с соседним островом по часовой стрелке. 
4. В качестве параметров островной модели было решено использовать одинаковые острова в количестве, равном количеству ядер процессора – 6.
5. Были произведены модификации классов ```IslandAlg``` и ```MasterSlaveAlg``` для подсчёта реального времени выполнения (wall time).
6. В качестве параметров ```IslandAlg``` были выбраны следующие значения: ```dimension = 50```, ```populationSize = 100```, ```generations = 10```. Соответственно, для ```MasterSlaveAlg``` были выбраны следующие значения: ```dimension = 50```, ```populationSize = 600``` (```IslandAlg``` имеет 6 островов, поэтому ```populationSize = 100 * 6```), ```generations = 500``` (```IslandAlg``` имеет 10 эпох по 50 итераций, поэтому ```generations = 10 * 50```).

## Результаты экспериментов по производительности и эффективности распределённых алгоритмов

Был произведён запуск алгоритма для различной сложности вычисления фитнесс-функци (```complexity```). Для реализации *Single-thread* варианта был использован класс ```MasterSlaveAlg``` с модификацией ```algorithm.setSingleThreaded(true)```.

|  | complexity=0 | | complexity=1 | |
| :--- | :---: | :---: | :---: | :---: |
|  | **Время выполнения (ms)** | **Результатат** | **Время выполнения (ms)** | **Результат** |
| Single-thread | 710.6 | 0.0 | 1336.9 | 6.50 |
| Master-slave | 761.6 | 0.0 | 1012.8 | 6.81 |
| Islands | 1792.7 | 0.0 | 1886.4 | 7.31 |

|  | complexity=2 | | complexity=3 | |
| :--- | :---: | :---: | :---: | :---: |
|  | **Время выполнения (ms)** | **Результатат** | **Время выполнения (ms)** | **Результат** |
| Single-thread | 1842.2 | 6.83 | 2343.9 | 6.72 |
| Master-slave | 1053.9 | 6.78 | 1086.8 | 6.60 |
| Islands | 1927.2 | 7.34 | 1976.8 | 7.44 |

|  | complexity=4 | | complexity=5 | |
| :--- | :---: | :---: | :---: | :---: |
|  | **Время выполнения (ms)** | **Результатат** | **Время выполнения (ms)** | **Результат** |
| Single-thread | 2852.8 | 6.69 | 3339.3 | 6.65 |
| Master-slave | 1114.4 | 6.69 | 1170.2 | 6.71 |
| Islands | 2022.2 | 7.40 | 2040.9 | 7.31 |

![Image 1](https://user-images.githubusercontent.com/29786176/228607831-a4977bed-f046-4505-851b-47067226ee64.png) ![Image 2](https://user-images.githubusercontent.com/29786176/228608101-af200a00-7f4e-4d29-beac-01dbde8aef95.png)

## Ответы на вопросы
**Q: Какая модель алгоритма лучше при каких условиях?**

**A:** При малой сложности расчёта фитнесс-функции (в случает текущей задачи ```complexity = 0```) *Single-thread* будет работать быстрее по времении выполнения, чем *Master-slave* и *Islands*. Однако, при этом возможно, что при *Islands* будет получен лучший результат. При возврастающей сложности фитнесс-функции (```complexity = 1...5```) *Master-slave* и *Islands* будут работать быстрее, чем *Single-thread* и меньше зависить от сложности расчёта фитнесс-функции. При этом, при помощи *Islands* возможно получить лучшее решение в сравнении с *Master-slave*, но при большем времени выполнения. 

**Q: Как повлияет увеличение размерности проблемы на алгоритмы?**

**A:** Их время работы увеличится, а качество финального решения останется прежним или упадёт. При этом скорость работы *Master-slave* пострадает меньше, чем *Single-thread* и *Islands*. В свою очередь, если у *Islands* до увеличения размерности проблемы было лучшее качество решения, то и после увеличения размерности проблемы оно, вероятно, будет лучшим.

**Q: Как повлияет увеличение размера популяции**

**A:** Время работы алгоритмов увеличится, а качество решения останется прежним или возврастёт. При этом скорость работы *Master-slave* пострадает меньше, чем *Single-thread* и *Islands*. Однако, при этом возможно, что соотношение времени работы и качества финального решения Islands повысится относительно *Single-thread* и *Master-slave*. Также, если у *Islands* до увеличения размера популяции было лучшее качество решения, то и после увеличения размерности проблемы оно, вероятно, будет лучшим.

**Q: Есть ли ограничение для количества островов?**

**A:** Да, присутствуют два ограничения. Софтверное ограничение - максимальное количество островов не может быть больше значения ```Integer.MAX_VALUE```. Хардварное ограничение - максимальное количество островов количеством оперативной памяти, которое может быть выделено для работы алгоритма. 
