# Генетический алгоритм для задачи оптимизации непрерывной функции

## Цель работы
Целью данной работы является получение студентом навыки разработки и анализа эволюционных операторов генетического алгоритма для решения задачи оптимизации непрерывной вещественнозначной функции.

## Выполнениие работы
В рамках рыботы был реализован ряд функций (методов) для запуска генетического алгоритма:

1. Был реализован метод ```generateRandomCandidate``` в классе ```MyFactory```. Данный метод генерирует последовательность размера ```dimension``` из вещественных чисел в диапазоне $[-5, 5]$. Генерация происходит при помощи метода ```nextDouble()```, который возвращает случайное значение из равномерного распределения в диапазоне $[0, 1]$ с поледующим масштабированием при помощи домножения на $10$ и вычета $5$.
2. Был реализован метод ```mate``` в классе ```MyCrossover```. Данный метод принимает на вход две последовательности размера ```dimension``` из вещественных чисел в диапазоне $[-5, 5]$ и возвращает две производных последовательности с теми же (вышеперечисленными) свойствами. В данном случае был реализован **Blend Crossover (BLX)**, взятый из книги [*Introduction to Evolutionary Algorithms*](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Introduction%20to%20Evolutionary%20Algorithms%20%5BYu%20%26%20Gen%202010-06-23%5D.pdf) за авторством *Xinjie Yu* и *Mitsuo Gen*. В отличие от арифмитического кроссовера, "который, на самом деле, является линейной интерполяцией из двух последовательностей", в BLX происходит дополнительное расширение пространства мутации за счёт слагаемого $\alpha (x_i^2 - x_i^1)$, в результате чего получается увеличить генерируемое разнообразие. Реализация была произведена в соответствии с описанием в книге, $\alpha$ была взята равной $0.5$.
3. Был реализован метод ```apply``` в классе ```MyMutation```. Данный метод принимает на вход массив из последовательностей вещественных чисел в диапазоне $[-5, 5]$ и размера ```dimension``` и возвращает массив с изменёнными последовательностями, удовлетворяющих (вышеперечисленными) свойствам. Мутация реализована следующим образом: в каждой последовательности изменяется один случайный элемент $p_i$ по правилу $p_i = p_i + nextDouble() \times nextGaussian()$. Идея заключается в небольшом случайном смещении, т.к. ```nextGaussian``` контролирует направление и величину изменения, а ```nextDouble``` случайным образом уменьшает данную величину изменения.

## Результаты экспериментов по производительности алгоритма

Был произведён запуск алгоритма для различных размеров проблемы (```dimension```). 

| Размер проблемы | Размер популяции | Количество итераций | **Результат** | 
| :--- | --- | --- | --- |
| 2 | 10 | 250 | **9.99** |
| 10 | 10 | 1250 | **9.97** |
| 20 | 10 | 2500 | **9.97** |
| 50 | 10 | 6250 | **9.86** |
| 100 | 12 | 9999 | **9.47** |

## Ответы на вопросы
**Q: Что важнее кроссовер или мутация?**

**A:** Кроссовер производит скрещивание уже **имеющихся** решений и в некотором смысле "ограничен" ими. В то же время, в большей степени случайная природа мутации позволяет получать потенциально любые решения из области определения. Таким образом, мутация (на мой взгляд) важнее кроссовера, т.к. мутацией можно получить любое значение, а диапазон значений кроссовера зависит от начальной инициализации и произведённых мутаций. При этом, стоит отметить, что грамматно подобранный алгоритм кроссовера может значительно помочь со скоростью сходимости генетического алгоритма. 

**Q: Как влияет значение параметра "размер популяции" на производительность и эффективность алгоритма?**

**A:** Во время проведения экспериментов было выялвено, что изменение числа популяций в рамках реализованного алгоритма ведёт либо к ухудшению производительности алгоритма, либо к незначительному улучшению. При увеличиении размера популяции скорость алгоритма падает, а при уменьшении – растёт.

**Q: Важно ли знать область определения переменных целевой функции**

**A:** Важно, поскольку иначе бы область поиска переменных была бы неизвестна, что могло бы привести в лучшем случае к увеличению вариантов перебора, а в худшем к "вылету" за область определения и получение ```NaN``` значений. 